const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const cors = require('cors');
const swaggerUi = require('swagger-ui-express');
const swaggerSpec = require('./swagger');
const db = require('./db');
const bot = require('./bot');
const commands = require('./commands');
const cron = require('./cron');
const apiRoutes = require('./api/v1');
const { 
  sanitizeRequestBody, 
  sanitizeQueryParams, 
  sanitizeParams,
  rateLimitConfig,
  securityHeaders 
} = require('./middleware/sanitize');
const { 
  detectSuspiciousActivity,
  logSecurityEvent 
} = require('./middleware/auth');
const {
  logger,
  requestLogger,
  errorLogger,
  performanceMonitor,
  statsRecorder,
  getHealthData
} = require('./middleware/monitoring');

// Load environment variables
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3100;

// Security Headers
app.use(helmet(securityHeaders));

// Monitoring Middleware
app.use(requestLogger);
app.use(performanceMonitor);
app.use(statsRecorder);

// Security Middleware
app.use(detectSuspiciousActivity);

// Input Sanitization
app.use(sanitizeRequestBody);
app.use(sanitizeQueryParams);
app.use(sanitizeParams);

  // CORS Configuration - Allow all origins for testing
const corsOptions = {
  origin: true, // Allow all origins for now
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  credentials: true,
  exposedHeaders: ['X-Total-Count', 'X-Page-Count']
};

app.use(cors(corsOptions));

// Rate Limiting
const generalLimiter = rateLimit(rateLimitConfig.general);
const adminLimiter = rateLimit(rateLimitConfig.admin);
const authLimiter = rateLimit(rateLimitConfig.auth);
const paymentLimiter = rateLimit(rateLimitConfig.payment);

app.use(generalLimiter); // Apply general rate limiting to all requests by default

// Body parsing middleware
app.use(express.json({ 
  limit: '10mb',
  verify: (req, res, buf) => {
    req.rawBody = buf.toString(); // Store raw body for potential signature verification
  }
}));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Serve static files from 'public' directory
app.use(express.static('public'));

// Swagger Documentation
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec, {
  customCss: '.swagger-ui .topbar { display: none }',
  customSiteTitle: 'Badminton Bot API Documentation'
}));

// Health check endpoint
app.get('/health', (req, res) => {
  const healthData = getHealthData();
  res.json(healthData);
});

// API Stats endpoint - moved to v1

// API Routes with specific rate limiting
app.use('/api/v1/auth', authLimiter);
app.use('/api/v1/admin', adminLimiter);
app.use('/api/v1/payments', paymentLimiter);
app.use('/api/v1', apiRoutes); // New API routes

// Test endpoints - moved to v1

// Webhook verification endpoint
app.get('/webhook', (req, res) => {
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];

  const result = bot.verifyWebhook(mode, token, challenge);
  
  if (result) {
    res.status(200).send(result);
  } else {
    res.status(403).send('Forbidden');
  }
});

// Webhook message endpoint
app.post('/webhook', async (req, res) => {
  try {
    const body = req.body;

    // Ki·ªÉm tra xem c√≥ ph·∫£i l√† tin nh·∫Øn t·ª´ Facebook kh√¥ng
    if (body.object === 'page') {
      // X·ª≠ l√Ω t·ª´ng entry
      for (const entry of body.entry) {
        const webhookEvent = entry.messaging[0];
        
        if (webhookEvent) {
          await handleWebhookEvent(webhookEvent);
        }
      }
      
      res.status(200).send('EVENT_RECEIVED');
    } else {
      res.status(404).send('Not Found');
    }
  } catch (error) {
    console.error('‚ùå Error processing webhook:', error);
    res.status(500).send('Internal Server Error');
  }
});

// X·ª≠ l√Ω webhook event
async function handleWebhookEvent(webhookEvent) {
  try {
    const senderId = webhookEvent.sender.id;
    const recipientId = webhookEvent.recipient.id;

    // Ki·ªÉm tra xem c√≥ ph·∫£i tin nh·∫Øn trong group kh√¥ng
    const isGroupMessage = webhookEvent.message?.is_echo === false && 
                          recipientId !== senderId;

    // N·∫øu l√† tin nh·∫Øn trong group, ch·ªâ x·ª≠ l√Ω vote v√† reply ri√™ng cho user
    if (isGroupMessage) {
      console.log(`üì® Group message detected from ${senderId}`);
      // Ch·ªâ x·ª≠ l√Ω vote, kh√¥ng reply trong group
      if (webhookEvent.message) {
        await handleGroupMessage(webhookEvent);
      }
      return; // Kh√¥ng x·ª≠ l√Ω th√™m
    }

    // X·ª≠ l√Ω tin nh·∫Øn 1-1 b√¨nh th∆∞·ªùng
    if (webhookEvent.message) {
      await handleMessage(webhookEvent);
    }
    
    // X·ª≠ l√Ω postback
    if (webhookEvent.postback) {
      await handlePostback(webhookEvent);
    }

  } catch (error) {
    console.error('‚ùå Error handling webhook event:', error);
  }
}

// X·ª≠ l√Ω tin nh·∫Øn group (ch·ªâ vote, reply ri√™ng cho user)
async function handleGroupMessage(event) {
  const senderId = event.sender.id;
  const recipientId = event.recipient.id; // Group ID
  const message = event.message;

  if (!message) return;

  // L∆∞u th√¥ng tin user n·∫øu ch∆∞a c√≥
  await bot.ensureUserExists(senderId, event.sender);

  // X·ª≠ l√Ω commands (admin)
  if (message.text && message.text.startsWith('/')) {
    const parts = message.text.split(' ');
    const command = parts[0].substring(1); // B·ªè d·∫•u /
    const args = parts.slice(1);

    // Ch·ªâ x·ª≠ l√Ω l·ªánh /vote trong group
    if (command.toLowerCase() === 'vote') {
      const result = await commands.handleCommand(senderId, command, args, recipientId);
      // Kh√¥ng c·∫ßn reply v√¨ ƒë√£ g·ª≠i v√†o group
      if (!result.skipReply) {
        await bot.sendTextMessage(senderId, result.message);
      }
      return;
    }
  }

  // X·ª≠ l√Ω vote commands
  if (message.text) {
    const text = message.text.toLowerCase().trim();
    
    // Ki·ªÉm tra c√°c l·ªánh vote
    if (text.includes('tham gia') || text.includes('ƒëi ch∆°i') || 
        text === 'c√≥' || text === 'yes') {
      await handleGroupVote(senderId, 'VOTE_YES');
    } else if (text.includes('kh√¥ng') || text === 'no') {
      await handleGroupVote(senderId, 'VOTE_NO');
    }
  }

  // X·ª≠ l√Ω quick reply vote
  if (message.quick_reply) {
    const payload = message.quick_reply.payload;
    if (payload === 'VOTE_YES' || payload === 'VOTE_NO') {
      await handleGroupVote(senderId, payload);
    }
  }
}

// X·ª≠ l√Ω vote t·ª´ group (g·ª≠i reply ri√™ng cho user)
async function handleGroupVote(senderId, voteType) {
  try {
    // L·∫•y ho·∫∑c t·∫°o session h√¥m nay
    let session = await db.getCurrentSession();
    if (!session) {
      const today = new Date();
      today.setHours(18, 0, 0, 0);
      session = await db.createSession(today);
    }

    // L·∫•y user
    const user = await db.getUserByFbId(senderId);
    if (!user) {
      // G·ª≠i tin nh·∫Øn ri√™ng cho user
      await bot.sendTextMessage(senderId, 'Vui l√≤ng ƒëƒÉng k√Ω th√¥ng tin tr∆∞·ªõc khi vote.');
      return;
    }

    // T·∫°o ho·∫∑c c·∫≠p nh·∫≠t vote
    await db.createVote(session.id, user.id, voteType);

    // L∆∞u audit log
    await db.createAuditLog(session.id, 'VOTE_CREATED', {
      userId: user.id,
      userName: user.name,
      voteType,
      timestamp: new Date().toISOString()
    });

    // L·∫•y th·ªëng k√™ hi·ªán t·∫°i
    const stats = await getVoteStats(session.id);
    
    // G·ª≠i tin nh·∫Øn ri√™ng cho user v·ªõi th·ªëng k√™
    const voteText = voteType === 'VOTE_YES' ? 'tham gia' : 'kh√¥ng tham gia';
    const message = `‚úÖ B·∫°n ƒë√£ ${voteText}!\n\nüìä Th·ªëng k√™ hi·ªán t·∫°i:\nüë• T·ªïng: ${stats.total} ng∆∞·ªùi\n‚úÖ Tham gia: ${stats.yes} ng∆∞·ªùi\n‚ùå Kh√¥ng tham gia: ${stats.no} ng∆∞·ªùi`;
    
    await bot.sendTextMessage(senderId, message);

  } catch (error) {
    console.error('‚ùå Error handling group vote:', error);
    await bot.sendTextMessage(senderId, 'C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω vote. Vui l√≤ng th·ª≠ l·∫°i.');
  }
}

// L·∫•y th·ªëng k√™ vote
async function getVoteStats(sessionId) {
  const votes = await db.prisma.vote.findMany({
    where: { sessionId },
    include: { user: true }
  });

  const yesVotes = votes.filter(v => v.voteType === 'VOTE_YES');
  const noVotes = votes.filter(v => v.voteType === 'VOTE_NO');

  return {
    total: votes.length,
    yes: yesVotes.length,
    no: noVotes.length,
    yesUsers: yesVotes.map(v => v.user.name),
    noUsers: noVotes.map(v => v.user.name)
  };
}

// X·ª≠ l√Ω tin nh·∫Øn
async function handleMessage(event) {
  const senderId = event.sender.id;
  const message = event.message;

  if (!message) return;

  // Ki·ªÉm tra user c√≥ t·ªìn t·∫°i ch∆∞a
  const existingUser = await db.getUserByFbId(senderId);
  const isNewUser = !existingUser;

  // L∆∞u th√¥ng tin user n·∫øu ch∆∞a c√≥
  await bot.ensureUserExists(senderId, event.sender);

  // N·∫øu l√† user m·ªõi, hi·ªÉn th·ªã menu l·∫ßn ƒë·∫ßu
  if (isNewUser && message.text && !message.quick_reply) {
    const user = await db.getUserByFbId(senderId);
    await bot.sendTextMessage(senderId, `Xin ch√†o! üëã`);
    await bot.sendMainMenu(senderId, user?.isAdmin || false);
    return;
  }

  // X·ª≠ l√Ω text message
  if (message.text) {
    await handleTextMessage(senderId, message.text);
  }

  // X·ª≠ l√Ω quick reply
  if (message.quick_reply) {
    await handleQuickReply(senderId, message.quick_reply);
  }
}

// X·ª≠ l√Ω tin nh·∫Øn text
async function handleTextMessage(senderId, text) {
  const lowerText = text.toLowerCase().trim();

  // Ki·ªÉm tra xem c√≥ ph·∫£i l√† command kh√¥ng
  if (lowerText.startsWith('/')) {
    const parts = text.split(' ');
    const command = parts[0].substring(1); // B·ªè d·∫•u /
    const args = parts.slice(1);

    const result = await commands.handleCommand(senderId, command, args);
    await bot.sendTextMessage(senderId, result.message);
  } else {
    // X·ª≠ l√Ω tin nh·∫Øn t·ª´ bot.js
    await bot.handleTextMessage(senderId, text);
  }
}

// X·ª≠ l√Ω quick reply
async function handleQuickReply(senderId, quickReply) {
  const payload = quickReply.payload;
  await bot.handleQuickReply(senderId, quickReply);
}

// X·ª≠ l√Ω postback
async function handlePostback(event) {
  const senderId = event.sender.id;
  const payload = event.postback.payload;
  await bot.handlePostback(senderId, payload);
}

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('\nüõë Received SIGINT, shutting down gracefully...');
  
  try {
    // D·ª´ng cron jobs
    cron.stop();
    
    // ƒê√≥ng database connection
    await db.disconnect();
    
    console.log('‚úÖ Graceful shutdown completed');
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Error during shutdown:', error);
    process.exit(1);
  }
});

process.on('SIGTERM', async () => {
  console.log('\nüõë Received SIGTERM, shutting down gracefully...');
  
  try {
    cron.stop();
    await db.disconnect();
    console.log('‚úÖ Graceful shutdown completed');
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Error during shutdown:', error);
    process.exit(1);
  }
});

// Error handling middleware
app.use(errorLogger);
app.use((error, req, res, next) => {
  logger.error('Unhandled error', {
    error: error.message,
    stack: error.stack,
    requestId: req.requestId,
    method: req.method,
    url: req.url,
    ip: req.ip
  });
  
  // Log security event for errors
  logSecurityEvent('UNHANDLED_ERROR', req, { 
    error: error.message, 
    stack: error.stack 
  });
  
  res.status(error.status || 500).json({
    success: false,
    error: process.env.NODE_ENV === 'production' ? 'Internal server error' : error.message,
    code: error.code || 'INTERNAL_ERROR',
    timestamp: new Date().toISOString(),
    requestId: req.requestId
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: 'Not Found' });
});

// Kh·ªüi ƒë·ªông server
async function startServer() {
  try {
    // K·∫øt n·ªëi database
    await db.connect();
    
    // Kh·ªüi ƒë·ªông cron scheduler
    cron.start();
    
    // Kh·ªüi ƒë·ªông server
    app.listen(PORT, () => {
      console.log(`üöÄ Server running on port ${PORT}`);
      console.log(`üì° Webhook URL: http://localhost:${PORT}/webhook`);
      console.log(`üè• Health check: http://localhost:${PORT}/health`);
      console.log(`üìö API Documentation: http://localhost:${PORT}/api-docs`);
      console.log(`üîê Admin Panel: http://localhost:${PORT}/admin.html`);
      console.log(`üìä API Stats: http://localhost:${PORT}/api/stats`);
      console.log(`üîí Security: Helmet, CORS, Rate Limiting enabled`);
    });
    
  } catch (error) {
    console.error('‚ùå Failed to start server:', error);
    process.exit(1);
  }
}

// Kh·ªüi ƒë·ªông server
startServer();
